<html>
<head>
<title>PLP 2e Foreword</title>
</head>
<body bgcolor="white">

<img align=right alt="PLP 2e cover" hspace=5 vspace=5
  src="../images/2e_small.jpg">

<h1><small><small>Foreword to</small></small><br>
Programming Language Pragmatics<br>
<font color=green>
<small><small>Second Edition</small></small></font></h1>

<h2><a href="https://www.linkedin.com/in/james-larus-42b3476/">James Larus</a>,
<small>Microsoft Research</small></h2>

<p>
Computer science excels at layering abstraction on abstraction.&nbsp; Our
field&#8217;s facility for hiding details behind a simplified
interface is both a virtue and a necessity.&nbsp; Operating systems,
databases, and compilers are very complex programs shaped by forty years
of theory and development.&nbsp; For the most part, programmers need
little or no understanding of the internal logic or structure of a piece
of software to use it productively.&nbsp; Most of the time, ignorance is
bliss.&nbsp;
<p>
Opaque abstraction, however, can become a brick wall, preventing forward
progress, instead of a sound foundation for new artifacts.&nbsp;
Consider the subject of this book, programs and programming
languages.&nbsp; What happens when a program runs too slowly, and
profiling cannot identify any obvious bottleneck or the bottleneck does
not have an algorithmic explanation?&nbsp; Some potential problems are
the translation of language constructs into machine instructions or how
the generated code interacts with a processor&#8217;s
architecture.&nbsp; Correcting these problems requires an understanding
that bridges levels of abstraction.&nbsp;
<p>
Abstraction can also stand in the path of learning.&nbsp; Simple
questions&#8212;how programs written in a small, stilted subset of
English can control machines that speak binary or why programming
languages, despite their ever growing variety and quantity, all seem
fairly similar&#8212;cannot be answered except by diving into the
details and understanding computers, compilers, and languages.&nbsp;
<p>
A computer science education, taken as a whole, can answer these
questions.&nbsp; Most undergraduate programs offer courses about
computer architecture, operating systems, programming language design,
and compilers.&nbsp; These are all fascinating courses that are well
worth taking&#8212;but difficult to fit into most study plans along with
the many other rich offerings of an undergraduate computer science
curriculum.&nbsp; Moreover, courses are often taught as self-contained
subjects and do not explain a subject&#8217;s connections to other
disciplines.&nbsp;
<p>
This book also answers these questions, by looking beyond the
abstractions that divide these subjects.&nbsp; Michael Scott is a
talented researcher who has made major contributions in language
implementation, run-time systems, and computer architecture.&nbsp; He is
exceptionally well qualified to draw on all of these fields to provide a
coherent understanding of modern programming languages.&nbsp; This book
not only explains language concepts and implementation details with
admirable clarity, but also shows how computer architecture and
compilers influence language design and implementation.&nbsp; Moreover,
it neatly illustrates how different languages are actually used, with
realistic examples to clearly show how problem domains shape languages
as well.&nbsp;
<p>
In interest of full disclosure, I must confess this book worried me when
I first read it.&nbsp; At the time, I thought Michael&#8217;s approach
de-emphasized programming languages and compilers in the curriculum and
would leave students with a superficial understanding of the
field.&nbsp; But now, having reread the book, I have come to realize
that in fact the opposite is true.&nbsp; By presenting them in their
proper context, this book shows that programming languages are the true
center of computer science, the bridges spanning the chasm between
programmer and machine.&nbsp;

<p>
<hr>
<a href="../home.html">
<img align=middle src="../images/up.gif" hspace=5 border=none>
  Back to the book home page</a>
<hr>
</body>
</html>
