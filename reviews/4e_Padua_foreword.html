<head>
<title>PLP 4e Foreword</title>
</head>
<body bgcolor="white">

<img align=right alt="PLP 4e cover"
  hspace=5 vspace=5 src="../images/4e_small.jpg">

<h1><small><small>Foreword to</small></small><br>
Programming Language Pragmatics<br>
<font color=green>
<small><small>Fourth Edition</small></small></font></h1>

<h2><a href="http://polaris.cs.uiuc.edu/~padua/">David A. Padua</a><br>
<small><small>
Donald Biggar Willett Professor<br>
Department of Computer Science<br>
University of Illinois at Urbana-Champaign</small></small></h2>

<p>
Programming languages are universally accepted as one of the core subjects
that every computer scientist must master.&nbsp; The reason is clear: these
languages are the main notation we use for developing products and for
communicating new ideas.&nbsp; They have influenced the field by enabling the
development of those multimillion-line programs that shaped the information
age.&nbsp; Their success is owed to the long-standing effort of the computer
science community in the creation of new languages and in the
development of
strategies for their implementation.&nbsp; The large number of computer scientists
mentioned in the footnotes and bibliographic notes in this book by Michael
Scott is a clear manifestation of the magnitude of this effort as is the
sheer number and diversity of topics it contains.&nbsp;
<p>
Over 75 programming languages are discussed.&nbsp; They represent the
best and most influential contributions in language design across time,
paradigms, and application domains.&nbsp; They are the outcome of decades of work
that led initially to Fortran and Lisp in the 1950s, to numerous languages
in the years that followed, and, in our times, to the popular dynamic
languages used to program the Web.&nbsp; The 75 plus languages span
numerous paradigms including imperative, functional, logic, static, dynamic,
sequential, shared-memory parallel, distributed-memory parallel, dataflow,
high-level, and intermediate languages.&nbsp; They include languages for
scientific computing, for symbolic manipulations, and for accessing
databases.&nbsp; This rich diversity of languages is crucial for programmer
productivity and is one of the great assets of the discipline of computing.&nbsp;
<p>
Cutting across languages, this book presents a detailed discussion of
control flow, types, and abstraction mechanisms.&nbsp; These are the
representations needed to develop programs that are well organized, modular,
easy to understand, and easy to maintain.&nbsp; Knowledge of these core features
and of their incarnation in today&rsquo;s languages is a basic foundation to
be an
effective programmer and to better understand computer science today.&nbsp;
<p>
Strategies to implement programming languages must be studied together with
the design paradigms.&nbsp; A reason is that success of a language depends on the
quality of its implementation.&nbsp; Also, the capabilities of these strategies
sometimes constraint the design of languages.&nbsp; The implementation of a
language starts with parsing and lexical scanning needed to compute the
syntactic structure of programs.&nbsp; Today&rsquo;s parsing techniques, described in
Part&nbsp;I, are among the most beautiful algorithms ever developed and are a
great example of the use of mathematical objects to create practical
instruments.&nbsp; They are worthwhile studying just as an intellectual
achievement.&nbsp; They are of course of great practical value, and a good way to
appreciate the greatness of these strategies is to go back to the first
Fortran compiler and study the ad hoc, albeit highly ingenious, strategy
used to implement precedence of operators by the pioneers that built that
compiler.&nbsp;
<p>
The other usual component of implementation are the compiler components that
carry out the translation from the high-level language representation to a
lower level form suitable for execution by real or virtual machines.&nbsp; The
translation can be done ahead of time, during execution (just in time), or
both.&nbsp; The book discusses these approaches and implementation strategies
including the elegant mechanisms of translation driven by parsing.&nbsp; To
produce highly efficient code, translation routines apply strategies to
avoid redundant computations, make efficient use of the memory hierarchy,
and take advantage of intra-processor parallelism.&nbsp; These, sometimes
conflicting goals, are undertaken by the optimization components of
compilers.&nbsp; Although this topic is typically outside the scope of a first
course on compilers, the book gives the reader access to a good overview of
program optimization in Part&nbsp;IV.&nbsp;
<p>
An important recent development in computing is the popularization of
parallelism and the expectation that, in the foreseeable future, performance
gains will mainly be the result of effectively exploiting this parallelism.&nbsp;
The book responds to this development by presenting the reader with a range
of topics in concurrent programming including mechanisms for
synchronization, communication, and coordination across threads.&nbsp; This
information will become increasingly important as parallelism consolidates
as the norm in computing.&nbsp;
<p>
Programming languages are the bridge between programmers and
machines.&nbsp; It is
in them that algorithms must be represented for execution.&nbsp; The study of
programming languages design and implementation offers great educational
value by requiring an understanding of the strategies used to connect
the different aspects of computing.&nbsp; By presenting such an extensive
treatment of the subject, Michael Scott&rsquo;s <em>Programming Language
Pragmatics</em>, is a great contribution to the literature and a valuable
source of information for computer scientists.&nbsp;

<p>
<hr>
<a href="../home.html">
<img align=middle src="../images/up.gif" hspace=5 border=none>
  Back to the book home page</a>
<hr>
</body>
</html>
